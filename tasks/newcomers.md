![image](https://github.com/user-attachments/assets/547a93d7-d511-4683-a3db-463577867f41)# Задание 1. Introduction to ASP.Net MVC
1.	Создать пустое Web-приложение. 
 ![image](https://github.com/user-attachments/assets/49456671-a8c5-423b-a590-bd9d54ee03a3)
2.	Создать контроллер CalculatorController с методами:
•	Sum(int x, int y) – сумма двух слагаемых

•	Prod(int x, int y) – умножение двух слагаемых

•	И другие операции по желанию.

3.	Создать представление Calculartor.cshtml. Разместить на нем два текстовых поля с лейблами «x» и «y» для ввода соответствующих переменных. Также разместить список радио-кнопок для выбора текущего действия (см. рисунок) и кнопку «Calc». По нажатию на кнопку должно производиться вычисление соответствующей операции над переменными, введенными в поля «x» и «y». 

4.	Результат операции должен записаться в лог в виде Дата Время X Операция Y = Результат (см. рисунок).
   ![image](https://github.com/user-attachments/assets/36e8f0b2-3e12-4ed5-8d93-3b6e5440e701)
 
# Задание 2. HTML, CSS
Необходимо сверстать макет будущего сайта.
2.1. Форма регистрации
Несколько текстовых полей, расположенных друг под другом и кнопка. Для почты и пароля использовать специальный тип у input.
 ![image](https://github.com/user-attachments/assets/51305e37-799e-4cf2-9fbc-f75ec64227df)

2.2. Форма авторизации
Два текстовых поля, расположенных друг под другом и кнопка. Для почты и пароля использовать специальный тип у input.
 ![image](https://github.com/user-attachments/assets/ad7530aa-941d-47db-b38a-620cfba222ca)

2.3. Страница со списком
В качестве элементов колонок могут быть кнопки, выпадающие списки и изображения. Изображения должны иметь фиксированную величину. Кнопки должны быть расположены в ряд.
 ![image](https://github.com/user-attachments/assets/99ca33fb-2ad0-4e5a-a3bb-c97b1c8af5c3)

2.4. Страница с показом детальной информации 
Только текст без возможности изменить что-либо.
 ![image](https://github.com/user-attachments/assets/ec247903-7a4c-4836-a66e-09ea78f747b7)

2.5. Страница с редактированием. 
Текстовые поля с возможностью редактирования.
 ![image](https://github.com/user-attachments/assets/688c8ce8-4b7b-409d-a0eb-eefcc6d8869e)

2.6. Модальное окно
См. предыдущие изображения (2.4 и 2.5).

2.7. Хлебные крошки
 ![image](https://github.com/user-attachments/assets/feca551f-300b-4a09-a9e2-a33a06de8db1)
 ![image](https://github.com/user-attachments/assets/2425cded-bbbf-4aa5-9858-2a5d599ef547)

Требования к реализации
Все страницы должны иметь единый стиль (цвет кнопок, ориентация контролов на странице, шрифт итп).
Скачивание из интернета готовых макетов не допускается.
Итоговое решение должно содержать следующую структуру: для картинок, скриптов (если есть) и стилей – собственные папки, необходимое количество html файлов с макетами страниц. Пустые папки создавать не нужно.
![image](https://github.com/user-attachments/assets/823938bf-557c-4c2e-add2-f5af849d699d)
1.	Отверстать шаблон каркаса верстки и разместить в нем некоторые реализованные элементы (форма авторизации, список, хлебные крошки, какой-то текстовый блок). 
2.	*Предусмотреть изменение местоположения элементов в случае узкого экрана (телефон/планшет)
3.	Посмотреть, как выглядят макеты в Internet Explorer и других браузерах.
 
#Задание 3. Basics of C#
Задания ниже выполнить в виде консольного приложения.
Реализация заданий должна находиться в отдельном классе, отличном от класса Program. 
При запуске консоли пользователю должна быть предоставлена возможность выбрать запускаемое задание. После завершения выполнения задания необходимо спросить у пользователя, хочет ли он повторить текущее задание, либо выбрать другое, либо выйти из приложения.
Для удобства тестирования рекомендуется в качестве тестовых значений использовать случайно сгенерированные входные значения, ограниченные определенными рамками. 
Например, если нужно вывести пирамиду из звездочек, то можно ограничить число рядов от 1 до 50. 
В случае необходимости ввести строку, необходимо предложить пользователю использовать строку по умолчанию или ввести собственную строку. 
Все задания должны корректно обрабатывать любые возникшие в процессе работы ошибки. Все некорректные действия пользователя должны отлавливаться и на них должны выводиться понятные сообщения об ошибке. 
Например, если пользователь пытается ввести отрицательное число в размерность массива, ему нужно указать, что «Размерность может быть только больше 0!».
В случае непредвиденной ошибки пользователю должно выводиться что-то вроде «Извините, произошла ошибка». Сам текст ошибки и её stack trace необходимо записать в лог (отдельный файл).

Задание 3.1
Написать программу, которая определяет площадь прямоугольника со сторонами a и b. Если пользователь вводит некорректные значения (отрицательные, или 0), должно выдаваться сообщение об ошибке. Возможность ввода пользователем строки вида «абвгд», или нецелых чисел игнорировать. 

Задание 3.2
Написать программу, которая запрашивает с клавиатуры число N и выводит на экран следующее «изображение», состоящее из N строк: 
![image](https://github.com/user-attachments/assets/78c91fae-8425-4f6e-b001-6b6bec4b5621)

Задание 3.3
Написать программу, которая запрашивает с клавиатуры число N и выводит на экран следующее «изображение», состоящее из N строк: 
 ![image](https://github.com/user-attachments/assets/5e0992f0-c8d1-4d9a-af74-5359e4de2cb4)

Задание 3.4
Написать программу, которая запрашивает с клавиатуры число N и выводит на экран следующее «изображение», состоящее из N треугольников: 
![image](https://github.com/user-attachments/assets/4169cba9-92b0-4693-9a71-6c91444c93b3)

Задание 3.5
Если выписать все натуральные числа меньше 10, кратные 3, или 5, то получим 3, 5, 6 и 9. Сумма этих чисел будет равна 23. Напишите программу, которая выводит на экран сумму всех чисел меньше 1000, кратных 3, или 5. 

Задание 3.6
Для выделения текстовой надписи можно использовать выделение жирным, курсивом и подчёркиванием. Предложите способ хранения информации о выделении надписи и напишите программу, которая позволяет назначать и удалять текстовой надписи выделение: 
![image](https://github.com/user-attachments/assets/3bdadd97-230d-419c-a90f-ef549baf2c96)

Задание 3.7
Написать программу, которая генерирует случайным образом элементы массива (число элементов в массиве и их тип определяются разработчиком), определяет для него максимальное и минимальное значения, сортирует массив и выводит полученный результат на экран. 
Примечание: LINQ запросы и готовые функции языка (Sort, Max и т.д.) использовать в данном задании запрещается.

Задание 3.8
Написать программу, которая заменяет все положительные элементы в трёхмерном массиве на нули. Число элементов в массиве и их тип определяются разработчиком.

Задание 3.9
Написать программу, которая определяет сумму неотрицательных элементов в одномерном массиве. Число элементов в массиве и их тип определяются разработчиком.

Задание 3.10
Элемент двумерного массива считается стоящим на чётной позиции, если сумма номеров его позиций по обеим размерностям является чётным числом (например, [1,1] – чётная позиция, а [1,2] - нет).  Определить сумму элементов массива, стоящих на чётных позициях.

Задание 3.11
Написать программу, которая определяет среднюю длину слова во введенной текстовой строке. Учесть, что символы пунктуации на длину слов влиять не должны. Регулярные выражения не использовать. И не пытайтесь прописать все ручками. Используйте стандартные методы класса String.

Задание 3.12
Написать программу, которая удваивает в первой введенной строки все символы, принадлежащие второй введенной строке.
```
Пример:  
Введите первую строку: написать программу, которая  
Введите вторую строку: описание  
Результирующая строка: ннааппииссаать ппроограамму, коотоораая
```

Задание 3.13
Проведите сравнительный анализ скорости работы классов String и StringBuilder для операции сложения строк:
```
string str = "";  
StringBuilder sb = new StringBuilder();  
int N = 100;  
for (int i = 0; i < N; i++)  
{  
str += "*";  
}  
for (int i = 0; i < N; i++)  
{  
sb.Append("*");  
} 
```

# Задание 4. Basics of OOP
4.1 Нарисовать диаграмму классов
Тебе была выдана тема финального проекта. Необходимо разработать диаграмму классов для указанной области.
4.2 Реализовать иерархию классов
По разработанной в предыдущем задании диаграмме реализовать иерархию классов в отдельном проекте (который будет заготовкой будущего DAL). 
Предусмотреть возможность вынесение определенных сущностей в папки и подпапки.
 
# Задание 5. Generics and Collections
Используя наработки по DAL реализовать следующий интерфейс:
```
interface IBaseService
{
	T Get<T>(int id) where T : class, new();

	List<T> GetAll<T>() where T : class, new();

	bool Save<T>(T entity);

	bool Delete(int id);
}
```
В качестве хранилища данных использовать списки.
Продемонстрировать работу всех методов в классе с тестами.
 
# Задание 6. Delegates and events
Задание 6.1
Написать программу, выполняющую сортировку массива строк по возрастанию длины. Если строки состоят из равного числа символов, их следует отсортировать по алфавиту. Реализовать метод сравнения строк отдельным методом, передаваемым в сортировку через делегат.

Задание 6.2
Написать программу, описывающую небольшой офис, в котором работают сотрудники – объекты класса Person, обладающие полем имя (Name). Каждый из сотрудников содержит пару методов: приветствие сотрудника, пришедшего на работу (принимает в качестве аргументов объект сотрудника и время его прихода)  и прощание с ним (принимает только объект сотрудника). В зависимости от времени суток, приветствие может быть различным: до 12 часов – «Доброе утро», с 12 до 17 – «Добрый день», начиная с 17 часов – «Добрый вечер». Каждый раз при входе очередного сотрудника в офис, все пришедшие ранее его приветствуют. При уходе сотрудника домой с ним также прощаются все присутствующие. Вызов процедуры приветствия/прощания производить через групповые делегаты. Факт прихода и ухода сотрудника отслеживается через генерируемые им события. Событие прихода описывается делегатом, передающим в числе параметров наследника EventArgs, явно содержащего поле с временем прихода.
Продемонстрировать работу офиса при последовательном приходе и уходе сотрудников.
Пример:
 ![image](https://github.com/user-attachments/assets/a44c03db-f800-49c4-a4c0-cb09df26fe2b)

 
# Задание 7. Extensions and LINQ
Задание 7.1
Напишите расширяющий метод, который определяет сумму элементов массива.

Задание 7.2
Напишите расширяющий метод, который определяет, является ли строка положительным целым числом. Методы Parse и TryParse не использовать.

Задание 7.3
Написать методы поиска элемента в массиве (например, поиск всех положительных элементов в массиве) в виде: 
1.	Метода, реализующего поиск напрямую; 
2.	Метода, которому условие поиска передаётся через делегат; 
3.	Метода, которому условие поиска передаётся через делегат в виде анонимного метода; 
4.	Метода, которому условие поиска передаётся через делегат в виде лямбда-выражения; 
5.	LINQ-выражения 
Сравнить скорость выполнения вычислений.
 
# Задание 8. SQL
Цель выполнения
Получить практические навыки работы с Query Analyzer для выполнения операторов языка Transact SQL. Освоить применение различных команд DML для получения, изменения и удаления данных в БД. Научиться разрабатывать запросы с применением следующих операторов и конструкций языка Transact SQL:  
•	DISTINCT, ORDER BY, IN, BETWEEN, LIKE, EXISTS, CASE; 
•	агрегатных функций SUM, COUNT и предложений GROUP BY и HAVING; 
•	соединений таблиц и самосоединений, конструкций Inner и Outer JOIN; 
•	простых и коррелированных подзапросов; 
Научиться разрабатывать хранимые процедуры и функции и вызывать их. Научиться применять и использовать курсоры
Ограничения
При выполнения задания использовать требования, изложенные в руководстве «Database Modeling Guidelines» EPAM Systems
Список заданий
## 1	Работа с типами данных Date, NULL значениями, трехзначная логика. Возвращение определенных значений в результатах запроса в зависимости от полученных первоначальных значений результата запроса. Высветка в результатах запроса только определенных колонок.

1.1	Выбрать в таблице Orders заказы, которые были доставлены после 6 мая 1998 года (колонка ShippedDate) включительно и которые доставлены с ShipVia >= 2. Формат указания даты должен быть верным при любых региональных настройках, согласно требованиям статьи “Writing International Transact-SQL Statements” в Books Online раздел “Accessing and Changing Relational Data Overview”. Этот метод использовать далее для всех заданий. Запрос должен высвечивать только колонки OrderID, ShippedDate и ShipVia. 

Пояснить почему сюда не попали заказы с NULL-ом в колонке ShippedDate. 
1.2	Написать запрос, который выводит только недоставленные заказы из таблицы Orders. В результатах запроса высвечивать для колонки ShippedDate вместо значений NULL строку ‘Not Shipped’ – использовать системную функцию CASЕ. Запрос должен высвечивать только колонки OrderID и ShippedDate.

1.3	Выбрать в таблице Orders заказы, которые были доставлены после 6 мая 1998 года (ShippedDate) не включая эту дату или которые еще не доставлены. В запросе должны высвечиваться только колонки OrderID (переименовать в Order Number) и ShippedDate (переименовать в Shipped Date). В результатах запроса высвечивать для колонки ShippedDate вместо значений NULL строку ‘Not Shipped’, для остальных значений высвечивать дату в формате по умолчанию.

## 2	Использование операторов IN, DISTINCT, ORDER BY, NOT
2.1	Выбрать из таблицы Customers всех заказчиков, проживающих в USA и Canada. Запрос сделать с только помощью оператора IN. Высвечивать колонки с именем пользователя и названием страны в результатах запроса. Упорядочить результаты запроса по имени заказчиков и по месту проживания.

2.2	Выбрать из таблицы Customers всех заказчиков, не проживающих в USA и Canada. Запрос сделать с помощью оператора IN. Высвечивать колонки с именем пользователя и названием страны в результатах запроса. Упорядочить результаты запроса по имени заказчиков.

2.3	Выбрать из таблицы Customers все страны, в которых проживают заказчики. Страна должна быть упомянута только один раз и список отсортирован по убыванию. Не использовать предложение GROUP BY. Высвечивать только одну колонку в результатах запроса. 

## 3	Использование оператора BETWEEN, DISTINCT
3.1	Выбрать все заказы (OrderID) из таблицы Order Details (заказы не должны повторяться), где встречаются продукты с количеством от 3 до 10 включительно – это колонка Quantity в таблице Order Details. Использовать оператор BETWEEN. Запрос должен высвечивать только колонку OrderID.

3.2	Выбрать всех заказчиков из таблицы Customers, у которых название страны начинается на буквы из диапазона b и g. Использовать оператор BETWEEN. Проверить, что в результаты запроса попадает Germany. Запрос должен высвечивать только колонки CustomerID и Country и отсортирован по Country.

3.3	Выбрать всех заказчиков из таблицы Customers, у которых название страны начинается на буквы из диапазона b и g, не используя оператор BETWEEN. С помощью опции “Execution Plan” определить какой запрос предпочтительнее 3.2 или 3.3 – для этого надо ввести в скрипт выполнение текстового Execution Plan-a для двух этих запросов, результаты выполнения Execution Plan надо ввести в скрипт в виде комментария и по их результатам дать ответ на вопрос – по какому параметру было проведено сравнение. Запрос должен высвечивать только колонки CustomerID и Country и отсортирован по Country.

## 4	Использование оператора LIKE
4.1	В таблице Products найти все продукты (колонка ProductName), где встречается подстрока 'chocolade'. Известно, что в подстроке 'chocolade' может быть изменена одна буква 'c' в середине - найти все продукты, которые удовлетворяют этому условию. Подсказка: результаты запроса должны высвечивать 2 строки.

5	Использование агрегатных функций (SUM, COUNT)
5.1	Найти общую сумму всех заказов из таблицы Order Details с учетом количества закупленных товаров и скидок по ним. Результат округлить до сотых и высветить в стиле 1 для типа данных money.  Скидка (колонка Discount) составляет процент из стоимости для данного товара. Для определения действительной цены на проданный продукт надо вычесть скидку из указанной в колонке UnitPrice цены. Результатом запроса должна быть одна запись с одной колонкой с названием колонки 'Totals'.

5.2	По таблице Orders найти количество заказов, которые еще не были доставлены (т.е. в колонке ShippedDate нет значения даты доставки). Использовать при этом запросе только оператор COUNT. Не использовать предложения WHERE и GROUP.

5.3	По таблице Orders найти количество различных покупателей (CustomerID), сделавших заказы. Использовать функцию COUNT и не использовать предложения WHERE и GROUP.

## 6	Явное соединение таблиц, самосоединения, использование агрегатных функций и предложений GROUP BY и HAVING 
6.1	По таблице Orders найти количество заказов с группировкой по годам. В результатах запроса надо высвечивать две колонки c названиями Year и Total. Написать проверочный запрос, который вычисляет количество всех заказов.

6.2	По таблице Orders найти количество заказов, cделанных каждым продавцом. Заказ для указанного продавца – это любая запись в таблице Orders, где в колонке EmployeeID задано значение для данного продавца. В результатах запроса надо высвечивать колонку с именем продавца (Должно высвечиваться имя полученное конкатенацией LastName & FirstName. Эта строка LastName & FirstName должна быть получена отдельным запросом в колонке основного запроса. Также основной запрос должен использовать группировку по EmployeeID.) с названием колонки ‘Seller’ и колонку c количеством заказов высвечивать с названием 'Amount'. Результаты запроса должны быть упорядочены по убыванию количества заказов. 

6.3	По таблице Orders найти количество заказов, cделанных каждым продавцом и для каждого покупателя. Необходимо определить это только для заказов сделанных в 1998 году. В результатах запроса надо высвечивать колонку с именем продавца (название колонки ‘Seller’), колонку с именем покупателя (название колонки ‘Customer’)  и колонку c количеством заказов высвечивать с названием 'Amount'. В запросе необходимо использовать специальный оператор языка T-SQL для работы с выражением GROUP (Этот же оператор поможет выводить строку “ALL” в результатах запроса). Группировки должны быть сделаны по ID продавца и покупателя. Результаты запроса должны быть упорядочены по продавцу, покупателю и по убыванию количества продаж. В результатах должна быть сводная информация по продажам. Т.е. в резульирующем наборе должны присутствовать дополнительно к информации о продажах продавца для каждого покупателя следующие строчки:
```
Seller		Customer	Amount
ALL 		ALL		<общее число продаж>
<имя>		ALL		<число продаж для данного продавца>
ALL		<имя>		<число продаж для данного покупателя>
<имя>		<имя>		<число продаж данного продавца для даннного покупателя>
```
6.4	Найти покупателей и продавцов, которые живут в одном городе. Если в городе живут только один или несколько продавцов или только один или несколько покупателей, то информация о таких покупателя и продавцах не должна попадать в результирующий набор. Не использовать конструкцию JOIN. В результатах запроса необходимо вывести следующие заголовки для результатов запроса: ‘Person’, ‘Type’ (здесь надо выводить строку ‘Customer’ или  ‘Seller’ в завимости от типа записи), ‘City’. Отсортировать результаты запроса по колонке ‘City’ и по ‘Person’.

6.5	Найти всех покупателей, которые живут в одном городе. В запросе использовать соединение таблицы Customers c собой - самосоединение. Высветить колонки CustomerID и City. Запрос не должен высвечивать дублируемые записи. Для проверки написать запрос, который высвечивает города, которые встречаются более одного раза в таблице Customers. Это позволит проверить правильность запроса.

6.6	По таблице Employees найти для каждого продавца его руководителя, т.е. кому он делает репорты. Высветить колонки с именами 'User Name' (LastName) и 'Boss'. В колонках должны быть высвечены имена из колонки LastName. Высвечены ли все продавцы в этом запросе?

## 7	Использование Inner JOIN
7.1	Определить продавцов, которые обслуживают регион 'Western' (таблица Region). Результаты запроса должны высвечивать два поля: 'LastName' продавца и название обслуживаемой территории ('TerritoryDescription' из таблицы Territories). Запрос должен использовать JOIN в предложении FROM. Для определения связей между таблицами Employees и Territories надо использовать графические диаграммы для базы Northwind.

## 8	Использование Outer JOIN
8.1	Высветить в результатах запроса имена всех заказчиков из таблицы Customers и суммарное количество их заказов из таблицы Orders. Принять во внимание, что у некоторых заказчиков нет заказов, но они также должны быть выведены в результатах запроса. Упорядочить результаты запроса по возрастанию количества заказов.

## 9	Использование подзапросов
9.1	Высветить всех поставщиков колонка CompanyName в таблице Suppliers, у которых нет хотя бы одного продукта на складе (UnitsInStock в таблице Products равно 0). Использовать вложенный SELECT для этого запроса с использованием оператора IN. Можно ли использовать вместо оператора IN оператор '=' ?

## 10	Коррелированный запрос
10.1	Высветить всех продавцов, которые имеют более 150 заказов. Использовать вложенный коррелированный SELECT.

## 11	Использование EXISTS
11.1	Высветить всех заказчиков (таблица Customers), которые не имеют ни одного заказа (подзапрос по таблице Orders). Использовать коррелированный SELECT и оператор EXISTS.

## 12	Использование строковых функций
12.1	Для формирования алфавитного указателя Employees высветить из таблицы Employees список только тех букв алфавита, с которых начинаются фамилии Employees (колонка LastName ) из этой таблицы. Алфавитный список должен быть отсортирован по возрастанию.

## 13	Разработка функций и процедур
13.1	Написать процедуру, которая возвращает самый крупный заказ для каждого из продавцов за определенный год. В результатах не может быть несколько заказов одного продавца, должен быть только один и самый крупный. В результатах запроса должны быть выведены следующие колонки: колонка с именем и фамилией продавца (FirstName и LastName – пример: Nancy Davolio), номер заказа и его стоимость. В запросе надо учитывать Discount при продаже товаров. Процедуре передается год, за который надо сделать отчет, и количество возвращаемых записей. Результаты запроса должны быть упорядочены по убыванию суммы заказа. Процедура должна быть реализована с использованием оператора SELECT и БЕЗ ИСПОЛЬЗОВАНИЯ КУРСОРОВ. Название функции соответственно GreatestOrders. Необходимо продемонстрировать использование этих процедур. Также помимо демонстрации вызовов процедур в скрипте Query.sql надо написать отдельный ДОПОЛНИТЕЛЬНЫЙ проверочный запрос для тестирования правильности работы процедуры GreatestOrders. Проверочный запрос должен выводить в удобном для сравнения с результатами работы процедур виде для определенного продавца для всех его заказов за определенный указанный год в результатах следующие колонки: имя продавца, номер заказа, сумму заказа. Проверочный запрос не должен повторять запрос, написанный в процедуре, - он должен выполнять только то, что описано в требованиях по нему.

13.2	Написать процедуру, которая возвращает заказы в таблице Orders, согласно указанному сроку доставки в днях (разница между OrderDate и ShippedDate).  В результатах должны быть возвращены заказы, срок которых превышает переданное значение или еще недоставленные заказы. Значению по умолчанию для передаваемого срока 35 дней. Название процедуры ShippedOrdersDiff. Процедура должна высвечивать следующие колонки: OrderID, OrderDate, ShippedDate, ShippedDelay (разность в днях между ShippedDate и OrderDate), SpecifiedDelay (переданное в процедуру значение).  Необходимо продемонстрировать использование этой процедуры.

13.3	Написать процедуру, которая высвечивает всех подчиненных заданного продавца, как непосредственных, так и подчиненных его подчиненных. В качестве входного параметра функции используется EmployeeID. Необходимо распечатать имена подчиненных и выровнять их в тексте (использовать оператор PRINT) согласно иерархии подчинения. Продавец, для которого надо найти подчиненных также должен быть высвечен. Название процедуры SubordinationInfo. В качестве алгоритма для решения этой задачи надо использовать пример, приведенный в Books Online и рекомендованный Microsoft для решения подобного типа задач. Продемонстрировать использование процедуры.

13.4	 Написать функцию, которая определяет, есть ли у продавца подчиненные. Возвращает тип данных BIT. В качестве входного параметра функции используется EmployeeID. Название функции IsBoss. Продемонстрировать использование функции для всех продавцов из таблицы Employees.

## 14	Работа по финальному проекту
На основе диаграммы классов проработайте архитектуру базы данных вашего финального проекта.
Напишите скрипт создания сущностей пользователя, ролей и зависимых сущностей (достаточных для выполнения CRUD операций над пользователями и выдачи им определенных ролей)
*Напишите скрипт создания оставшихся сущностей вашей диаграммы. 
Требования к оформлению
1.	В качестве результата выполненного задания необходимо представить файлы, указанные ниже в списке. Перед сдачей задания на проверку обязательно проверьте, что скрипты можно запускать несколько раз и это не вызывает ошибки.
2.	Задание преставляет собой:
•	Query.sql - в нем должны быть приведены все требуемые запросы и примеры использования разработанных процедур и функций. В файле должны быть выполнены все необходимые действия для использования базы Northwind при запуске на выполнение этого файла. Перед каждым запросом должен быть комментарий, содержащий номер запроса и текст описания задания. Если в задании есть вопрос, то ответ должен быть дан также в комментарии к запросу.
•	Procedure.sql – в нем должны быть исходные текста процедур и функций задания. В файле должны быть выполнены все необходимые действия по инсталляции процедур и функций в базу Northwind при выполнении этого файла. Инсталляция должна учитывать тот факт, что процедуры с данным именем могут пристутствовать в базе. Перед каждой процедурой или функцией должен быть комментарий, соответствующий ее номеру в задании. ПРИМЕРЫ использования процедур должны быть приведены в файле Query.sql

# Задание 9. ADO.Net
Формулировка задания
Нашей задачей является разработка части DAL (Data Access Layer) к базе вашего будущего финального проекта. При этом необходимо соблюдать ряд требований:
•	DAL предоставляет объектный интерфейс. Т.е. данные которые он принимает и выдает на вход являются обычными POCO (plain old CLR object) объектами
•	DAL должен быть спроектирован таким образом, чтобы его можно было легко заменить на fakes или mocks при модульном тестировании бизнес-слоя
•	DAL должен поддерживать подключение к произвольной базе (строки подключения нигде не хардкодятся).
•	DAL должен быть спроектирован максимально в provider independent стиле. При этом должна быть оставлена возможность заменить некоторые методы на специфические для конкретной СУБД

Задание 9.1
Реализовать UserRepository, который должен наследоваться от BaseRepository, реализующего следующий интерфейс:
```
interface IBaseRepository
{
	T Get<T>(int id) where T : class, new();

	List<T> GetAll<T>() where T : class, new();

	bool Save<T>(T entity);

	bool Delete(int id);
}
```
Задание 9.2
Добавить в существующий проект тестов класс UserRepositoryTests, в котором реализовать проверку корректности работы всех методов репозитория пользователей.

Задание 9.3
Создать UserService и в его методах обращаться к соответствующим методам UserRepository через инъекцию зависимостей. Для создания реализаций сервиса и репозитория рекомендуется придерживаться следующей схемы:
```
class User
{

}

interface IBaseRepository<T>
{
	T Get<T>(int id) where T : class, new();

	List<T> GetAll<T>() where T : class, new();

	bool Save<T>(T entity);

	bool Delete(int id);
}

class BaseRepository<T> : IBaseRepository<T>
{
	public bool Delete(int id)
	{
		throw new NotImplementedException();
	}

	public T Get<T>(int id) where T : class, new()
	{
		throw new NotImplementedException();
	}

	public List<T> GetAll<T>() where T : class, new()
	{
		throw new NotImplementedException();
	}

	public bool Save<T>(T entity)
	{
		throw new NotImplementedException();
	}
}

interface IUserRepository : IBaseRepository<User>
{
}

class UserRepository : IUserRepository
{
	public bool Delete(int id)
	{
		throw new NotImplementedException();
	}

	public T Get<T>(int id) where T : class, new()
	{
		throw new NotImplementedException();
	}

	public List<T> GetAll<T>() where T : class, new()
	{
		throw new NotImplementedException();
	}

	public bool Save<T>(T entity)
	{
		throw new NotImplementedException();
	}
}

interface IBaseService<T>
{
	T Get<T>(int id) where T : class, new();

	List<T> GetAll<T>() where T : class, new();

	bool Save<T>(T entity);

	bool Delete(int id);
}

class BaseService<T> : IBaseService<T>
{
	public bool Delete(int id)
	{
		throw new NotImplementedException();
	}

	public T Get<T>(int id) where T : class, new()
	{
		throw new NotImplementedException();
	}

	public List<T> GetAll<T>() where T : class, new()
	{
		throw new NotImplementedException();
	}

	public bool Save<T>(T entity)
	{
		throw new NotImplementedException();
	}
}

class UserService : BaseService<User>
{
	private IUserRepository userRepo;

	public UserService(IUserRepository userRepo)
	{
		this.userRepo = userRepo;
	}
}
```

Задание 9.4
Напишите хранимую процедуру GetAllUsers, принимающую на вход количество возвращаемых записей. Добавте в репозиторий метод, вызывающий эту хранимку.
IoC контейнер
Контейнер необходимо инициализировать в Global.asax MVC приложения в методе Application_Start:
```
protected void Application_Start()
{
       //some code...
       DependencyResolver.SetResolver(new NinjectDependencyResolver(new StandardKernel()));
//some code...
}

public class NinjectDependencyResolver : IDependencyResolver
{
    private IKernel kernel;

    public NinjectDependencyResolver(IKernel kernelParam)
    {
        this.kernel = kernelParam;
        this.AddBindings();
    }

    public object GetService(Type serviceType)
    {
        return this.kernel.TryGet(serviceType);
    }

    public IEnumerable<object> GetServices(Type serviceType)
    {
        return this.kernel.GetAll(serviceType);
    }

    private void AddBindings()
    {
        this.kernel.Bind<IUserService>().To<UserService>();
    this.kernel.Bind<IUserRepository>().To<UserRepository>();
    }
}
```

# Задание 10. ASP.Net MVC

Задание 10.1
Реализуйте следующие контроллеры для административной части вашего приложения: 
•	UserController (CRUD)
•	RoleController (CRUD)

Задание 10.2
Реализуйте представления для всех экшенов контроллеров из задания 10.1.

Задание 10.3
Добавьте оставшиеся контроллеры со всеми необходимыми экшенами, которые могут понадобиться для реализации всего функционала финальной работы.
Сами экшены реализовывать не нужно. Достаточно сделать заглушки на них (например, возвращать пустую или заполненную дефолтными значениями запись вью-модели).
Разработайте и реализуйте все необходимые для функционирования экшенов вью-модели.

Задание 10.4
Создайте кастомный роутинг для следующих методов:
```
/create-<model> 	Создание новой записи. Например, /create-user, /create-order итп
/<model>/<id>		Получение конкретной записи по уникальному идентификатору. Например, /user/10, /order/1023
/<model>/<id>/edit 	Редактирование записи. Например, /user/10/edit, /order/1023/edit
```
/<model>/<id>/delete 	Удаление записи. Например, /user/10/delete, /order/1023/delete
/<model>s	Страница со списком всех записей определенной модели. Например, /users, /orders
/<model>s/<string>	Поиск по определенной строке в списке всех записей. По сути фильтр. Например, /users/John, /orders/4473729
В дальнейшем придерживайтесь этого роутинга для всех новых контроллеров.
